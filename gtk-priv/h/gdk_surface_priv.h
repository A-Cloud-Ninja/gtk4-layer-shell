/* AUTOGENERATED, DO NOT EDIT DIRECTLY
 * See gtk-priv/README.md for more information
 *
 * This file is part of gtk-layer-shell
 *
 * Copyright (C) 2019 Red Hat, Inc.
 * Copyright Â© 2023 gtk-priv/scripts/code.py
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef GDK_SURFACE_PRIV_H
#define GDK_SURFACE_PRIV_H

#include "common.h"

typedef struct _GdkSurface GdkSurface;

// Version ID 0
// Valid for GTK master
struct _GdkSurface_v3_0_0
{
  GObject parent_instance;
  GdkDisplay *display;
  GdkSurface *transient_for;
  GdkSurface *parent;
  GList *children;
  guint set_is_mapped_source_id;
  gboolean pending_is_mapped;
  gboolean is_mapped;
  gpointer widget;
  int x;
  int y;
  GdkGLContext *gl_paint_context;
  cairo_region_t *update_area;
  guint update_freeze_count;
  GdkFrameClockPhase pending_phases;
  cairo_region_t *active_update_area;
  GdkToplevelState pending_set_flags;
  GdkToplevelState pending_unset_flags;
  GdkToplevelState state;
  guint8 resize_count;
  guint8 alpha;
  guint8 fullscreen_mode;
  guint modal_hint : 1;
  guint destroyed : 2;
  guint in_update : 1;
  guint frame_clock_events_paused : 1;
  guint autohide : 1;
  guint shortcuts_inhibited : 1;
  guint request_motion : 1;
  guint request_motion_id;
  struct {
    GdkGravity surface_anchor;
    GdkGravity rect_anchor;
  } popup;
  guint update_and_descendants_freeze_count;
  int width;
  int height;
  GdkCursor *cursor;
  GHashTable *device_cursor;
  cairo_region_t *input_region;
  GList *devices_inside;
  GdkFrameClock *frame_clock;
  GSList *draw_contexts;
  GdkDrawContext *paint_context;
  cairo_region_t *opaque_region;
  GdkSeat *current_shortcuts_inhibited_seat;
};

// For internal use only
int gdk_surface_priv_get_version_id() {
  static int version_id = -1;
  
  if (version_id == -1) {
    gtk_priv_assert_gtk_version_valid();
    int combo = gtk_get_minor_version() * 1000 + gtk_get_micro_version();
  
    switch (combo) {
        break;
  
      default:
        gtk_priv_warn_gtk_version_may_be_unsupported();
    }
  
    {
      version_id = 0;
    }
  }
  
  return version_id;
}

// GdkSurface::parent_instance

GObject * gdk_surface_priv_get_parent_instance_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GObject *)&((struct _GdkSurface_v3_0_0*)self)->parent_instance;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::display

GdkDisplay * gdk_surface_priv_get_display(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->display;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_display(GdkSurface * self, GdkDisplay * display) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->display = display; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::transient_for

GdkSurface * gdk_surface_priv_get_transient_for(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->transient_for;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_transient_for(GdkSurface * self, GdkSurface * transient_for) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->transient_for = transient_for; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::parent

GdkSurface * gdk_surface_priv_get_parent(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->parent;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_parent(GdkSurface * self, GdkSurface * parent) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->parent = parent; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::children

GList * gdk_surface_priv_get_children(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->children;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_children(GdkSurface * self, GList * children) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->children = children; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::set_is_mapped_source_id

guint gdk_surface_priv_get_set_is_mapped_source_id(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->set_is_mapped_source_id;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_set_is_mapped_source_id(GdkSurface * self, guint set_is_mapped_source_id) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->set_is_mapped_source_id = set_is_mapped_source_id; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::pending_is_mapped

gboolean gdk_surface_priv_get_pending_is_mapped(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->pending_is_mapped;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_pending_is_mapped(GdkSurface * self, gboolean pending_is_mapped) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->pending_is_mapped = pending_is_mapped; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::is_mapped

gboolean gdk_surface_priv_get_is_mapped(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->is_mapped;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_is_mapped(GdkSurface * self, gboolean is_mapped) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->is_mapped = is_mapped; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::widget

gpointer gdk_surface_priv_get_widget(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->widget;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_widget(GdkSurface * self, gpointer widget) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->widget = widget; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::x

int gdk_surface_priv_get_x(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->x;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_x(GdkSurface * self, int x) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->x = x; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::y

int gdk_surface_priv_get_y(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->y;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_y(GdkSurface * self, int y) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->y = y; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::gl_paint_context

GdkGLContext * gdk_surface_priv_get_gl_paint_context(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->gl_paint_context;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_gl_paint_context(GdkSurface * self, GdkGLContext * gl_paint_context) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->gl_paint_context = gl_paint_context; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::update_area

cairo_region_t * gdk_surface_priv_get_update_area(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->update_area;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_update_area(GdkSurface * self, cairo_region_t * update_area) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->update_area = update_area; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::update_freeze_count

guint gdk_surface_priv_get_update_freeze_count(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->update_freeze_count;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_update_freeze_count(GdkSurface * self, guint update_freeze_count) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->update_freeze_count = update_freeze_count; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::pending_phases

GdkFrameClockPhase * gdk_surface_priv_get_pending_phases_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GdkFrameClockPhase *)&((struct _GdkSurface_v3_0_0*)self)->pending_phases;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::active_update_area

cairo_region_t * gdk_surface_priv_get_active_update_area(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->active_update_area;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_active_update_area(GdkSurface * self, cairo_region_t * active_update_area) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->active_update_area = active_update_area; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::pending_set_flags

GdkToplevelState * gdk_surface_priv_get_pending_set_flags_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GdkToplevelState *)&((struct _GdkSurface_v3_0_0*)self)->pending_set_flags;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::pending_unset_flags

GdkToplevelState * gdk_surface_priv_get_pending_unset_flags_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GdkToplevelState *)&((struct _GdkSurface_v3_0_0*)self)->pending_unset_flags;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::state

GdkToplevelState * gdk_surface_priv_get_state_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GdkToplevelState *)&((struct _GdkSurface_v3_0_0*)self)->state;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::resize_count

guint8 * gdk_surface_priv_get_resize_count_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (guint8 *)&((struct _GdkSurface_v3_0_0*)self)->resize_count;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::alpha

guint8 * gdk_surface_priv_get_alpha_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (guint8 *)&((struct _GdkSurface_v3_0_0*)self)->alpha;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::fullscreen_mode

guint8 * gdk_surface_priv_get_fullscreen_mode_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (guint8 *)&((struct _GdkSurface_v3_0_0*)self)->fullscreen_mode;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::modal_hint

guint gdk_surface_priv_get_modal_hint(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->modal_hint;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_modal_hint(GdkSurface * self, guint modal_hint) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->modal_hint = modal_hint; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::destroyed

guint gdk_surface_priv_get_destroyed(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->destroyed;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_destroyed(GdkSurface * self, guint destroyed) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->destroyed = destroyed; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::in_update

guint gdk_surface_priv_get_in_update(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->in_update;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_in_update(GdkSurface * self, guint in_update) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->in_update = in_update; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::frame_clock_events_paused

guint gdk_surface_priv_get_frame_clock_events_paused(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->frame_clock_events_paused;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_frame_clock_events_paused(GdkSurface * self, guint frame_clock_events_paused) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->frame_clock_events_paused = frame_clock_events_paused; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::autohide

guint gdk_surface_priv_get_autohide(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->autohide;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_autohide(GdkSurface * self, guint autohide) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->autohide = autohide; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::shortcuts_inhibited

guint gdk_surface_priv_get_shortcuts_inhibited(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->shortcuts_inhibited;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_shortcuts_inhibited(GdkSurface * self, guint shortcuts_inhibited) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->shortcuts_inhibited = shortcuts_inhibited; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::request_motion

guint gdk_surface_priv_get_request_motion(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->request_motion;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_request_motion(GdkSurface * self, guint request_motion) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->request_motion = request_motion; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::request_motion_id

guint gdk_surface_priv_get_request_motion_id(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->request_motion_id;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_request_motion_id(GdkSurface * self, guint request_motion_id) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->request_motion_id = request_motion_id; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::popup.surface_anchor

GdkGravity * gdk_surface_priv_get_popup_surface_anchor_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GdkGravity *)&((struct _GdkSurface_v3_0_0*)self)->popup.surface_anchor;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::popup.rect_anchor

GdkGravity * gdk_surface_priv_get_popup_rect_anchor_ptr(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return (GdkGravity *)&((struct _GdkSurface_v3_0_0*)self)->popup.rect_anchor;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::update_and_descendants_freeze_count

guint gdk_surface_priv_get_update_and_descendants_freeze_count(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->update_and_descendants_freeze_count;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_update_and_descendants_freeze_count(GdkSurface * self, guint update_and_descendants_freeze_count) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->update_and_descendants_freeze_count = update_and_descendants_freeze_count; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::width

int gdk_surface_priv_get_width(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->width;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_width(GdkSurface * self, int width) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->width = width; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::height

int gdk_surface_priv_get_height(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->height;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_height(GdkSurface * self, int height) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->height = height; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::cursor

GdkCursor * gdk_surface_priv_get_cursor(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->cursor;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_cursor(GdkSurface * self, GdkCursor * cursor) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->cursor = cursor; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::device_cursor

GHashTable * gdk_surface_priv_get_device_cursor(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->device_cursor;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_device_cursor(GdkSurface * self, GHashTable * device_cursor) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->device_cursor = device_cursor; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::input_region

cairo_region_t * gdk_surface_priv_get_input_region(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->input_region;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_input_region(GdkSurface * self, cairo_region_t * input_region) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->input_region = input_region; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::devices_inside

GList * gdk_surface_priv_get_devices_inside(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->devices_inside;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_devices_inside(GdkSurface * self, GList * devices_inside) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->devices_inside = devices_inside; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::frame_clock

GdkFrameClock * gdk_surface_priv_get_frame_clock(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->frame_clock;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_frame_clock(GdkSurface * self, GdkFrameClock * frame_clock) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->frame_clock = frame_clock; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::draw_contexts

GSList * gdk_surface_priv_get_draw_contexts(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->draw_contexts;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_draw_contexts(GdkSurface * self, GSList * draw_contexts) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->draw_contexts = draw_contexts; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::paint_context

GdkDrawContext * gdk_surface_priv_get_paint_context(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->paint_context;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_paint_context(GdkSurface * self, GdkDrawContext * paint_context) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->paint_context = paint_context; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::opaque_region

cairo_region_t * gdk_surface_priv_get_opaque_region(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->opaque_region;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_opaque_region(GdkSurface * self, cairo_region_t * opaque_region) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->opaque_region = opaque_region; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurface::current_shortcuts_inhibited_seat

GdkSeat * gdk_surface_priv_get_current_shortcuts_inhibited_seat(GdkSurface * self) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: return ((struct _GdkSurface_v3_0_0*)self)->current_shortcuts_inhibited_seat;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_priv_set_current_shortcuts_inhibited_seat(GdkSurface * self, GdkSeat * current_shortcuts_inhibited_seat) {
  switch (gdk_surface_priv_get_version_id()) {
    case 0: ((struct _GdkSurface_v3_0_0*)self)->current_shortcuts_inhibited_seat = current_shortcuts_inhibited_seat; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

#endif // GDK_SURFACE_PRIV_H
